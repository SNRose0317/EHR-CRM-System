{"version":3,"file":"ucumLhcUtils.js","names":["_ucumJsonDefs","require","intUtils_","_interopRequireWildcard","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","Ucum","UnitTables","UnitString","UcumLhcUtils","constructor","getInstance","unitsCount","ucumJsonDefs","loadJsonDefs","uStrParser_","massDimIndex_","getMassDimensionIndex","useHTMLInMessages","use","undefined","useBraceMsgForEachString","validateUnitString","uStr","suggest","valConv","resp","getSpecifiedUnit","theUnit","retObj","csCode_","name_","guidance_","status","detectConversionType","fromUnit","toUnit","conversionType","moleExp_","equivalentExp_","dim_","getElementAt","convertUnitTo","fromUnitCode","fromVal","toUnitCode","options","molecularWeight","charge","returnObj","trim","push","_checkFromVal","parseResp","concat","convertType","msgCountBeforeConvert","length","convertFrom","err","message","isMolMassCommensurable","needMoleWeightMsg_","convertMolMass","isEqMassCommensurable","needEqWeightMsg_","needEqChargeMsg_","convertEqMass","isEqMolCommensurable","convertEqMol","isEqMolMassCommensurable","convertEqMolMass","convertToBaseUnits","inputUnitLookup","unit","msg","retMsg","isArbitrary_","unitToExp","dimVec","dimVec_","baseUnitString","dimVecIndexToBaseUnit","dimVecIndexToBaseUnit_","len","exp","retUnitLookup","retUnit","magnitude","toString","fromUnitIsSpecial","isSpecial_","responseObj","isNaN","isNumericString","checkSynonyms","theSyn","getSynonyms","uName","utab","getUnitByCode","parseString","console","log","unshift","origString","commensurablesList","fromName","categoryList","commUnits","fromDim","getProperty","getUnitsByDimension","filter","item","indexOf","category_","exports"],"sources":["../source/ucumLhcUtils.js"],"sourcesContent":["/**\n * This class provides a single point of access to the LHC UCUM utilities\n *\n * @author Lee Mericle\n *\n */\nvar Ucum = require('./config.js').Ucum;\nimport {ucumJsonDefs} from './ucumJsonDefs.js';\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar UnitString = require('./unitString.js').UnitString;\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\n/**\n * UCUM external utilities class\n */\nexport class UcumLhcUtils {\n\n  /**\n   * Constructor.  This loads the json prefix and unit definitions if\n   * they haven't been loaded already and creates itself as a singleton object.\n   *\n   */\n  constructor() {\n\n    if (UnitTables.getInstance().unitsCount() === 0) {\n\n      // Load the prefix and unit objects\n      ucumJsonDefs.loadJsonDefs();\n    }\n\n    // Get the UnitString parser that will be used with this instance\n    // of the LHC Utilities\n    this.uStrParser_ = UnitString.getInstance();\n\n    // Get a copy of the mass dimension index.\n    this.massDimIndex_ =  UnitTables.getInstance().getMassDimensionIndex();\n  } // end constructor\n\n\n  /**\n   * This method calls the useHTMLInMessages method on the UnitString\n   * object.  It should be called by web applications that use\n   * these utilities.\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useHTMLInMessages(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useHTMLInMessages(use);\n  }\n\n\n  /**\n   * This method calls the useBraceMsgForEachString method on the UnitString\n   * object.  It should be called by web applications where unit\n   * strings are validated individually (as opposed to validating a whole\n   * file of unit strings).\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useBraceMsgForEachString(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useBraceMsgForEachString(use);\n  }\n\n\n  /**\n   * This method validates a unit string.  It first checks to see if the\n   * string passed in is a unit code that is found in the unit codes table.\n   * If it is not found it parses the string to see if it resolves to a\n   * valid unit string.\n   *\n   * If a valid unit cannot be found, the string is tested for some common\n   * errors, such as missing brackets or a missing multiplication operator.\n   * If found, the error is reported in the messages array that is returned.\n   *\n   * If a valid unit cannot be found and an error cannot be discerned, this\n   * may return, if requested, a list of suggested units in the messages\n   * array that is returned.  Suggestions are based on matching the expression\n   * with unit names and synonyms.\n   *\n   * @param uStr the string to be validated\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @param valConv a string indicating if this validation request was initiated\n   *  by a validation task ('validate') or a conversion task ('convert'),\n   *  used only for the demo code, and the default is 'Validator' if the\n   *  parameter is not specified;\n   * @returns an object with five properties:\n   *  'status' will be 'valid' (the uStr is a valid UCUM code), 'invalid'\n   *     (the uStr is not a valid UCUM code, and substitutions or\n   *     suggestions may or may not be returned, depending on what was\n   *     requested and found); or 'error' (an input or programming error\n   *     occurred);\n   *  'ucumCode' the valid ucum code, which may differ from what was passed\n   *    in (e.g., if 'Gauss' is passed in, this will contain 'G') OR null if\n   *    the string was flagged as invalid or an error occurred;\n   *  'msg' is an array of one or more messages, if the string is invalid or\n   *        an error occurred, indicating the problem, or an explanation of a\n   *        substitution such as the substitution of 'G' for 'Gauss', or\n   *        an empty array if no messages were generated;\n   *  'unit' which is null if no unit is found, or a hash for a unit found:\n   *    'code' is the unit's ucum code (G in the above example;\n   *    'name' is the unit's name (Gauss in the above example); and\n   *    'guidance' is the unit's guidance/description data; and\n   *  'suggestions' if suggestions were requested and found, this is an array\n   *     of one or more hash objects.  Each hash contains three elements:\n   *     'msg' which is a message indicating what part of the uStr input\n   *        parameter the suggestions are for;\n   *     'invalidUnit' which is the unit expression the suggestions are\n   *        for; and\n   *     'units' which is an array of data for each suggested unit found.\n   *        Each array will contain the unit code, the unit name and the\n   *        unit guidance (if any).\n   *     If no suggestions were requested and found, this property is not\n   *     returned.\n   */\n  validateUnitString(uStr, suggest, valConv) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    if (valConv === undefined)\n      valConv = 'validate' ;\n\n    let resp = this.getSpecifiedUnit(uStr, valConv, suggest);\n    let theUnit = resp['unit'];\n    let retObj = !theUnit ? {'ucumCode': null} :\n      {'ucumCode': resp['origString'],\n       'unit': {'code': theUnit.csCode_,\n                'name': theUnit.name_,\n                'guidance': theUnit.guidance_ }};\n    retObj.status = resp.status;\n    if (resp['suggestions']) {\n      retObj['suggestions'] = resp['suggestions'];\n    }\n    retObj['msg'] = resp['retMsg'];\n    return retObj;\n\n  } // end validateUnitString\n\n\n// Note that below when the value of ConversionType is mol|mass, it refers to\n// either a conversion from mol to mass or from mass to mol.\n/**\n * @typedef {\n *   'normal',\n *   'mol|mass',\n *   'eq|mass',\n *   'eq|mol',\n *   'eq|mol|mass'\n * } ConversionType\n */\n\n /**\n  * Detects the type of conversion between two units.\n  *\n  * @param {Object} fromUnit - The unit to convert from.\n  * @param {Object} toUnit - The unit to convert to.\n  * @returns {ConversionType} conversionType - The type of conversion as a string.\n  */\n  detectConversionType(fromUnit, toUnit) {\n    /** @type {ConversionType} */\n    let conversionType;\n    if (fromUnit.moleExp_ == toUnit.moleExp_ &&\n        fromUnit.equivalentExp_ == toUnit.equivalentExp_) {\n      // Since the powers of the equivalents and mole in the units are the same in both\n      // units, no conversion is going to happen between mass, mol, and eq.\n      // There is the possibility that someone is trying to convert 'g' to 'g2',\n      // but we will handle that as the \"normal\" case (and later find it invalid).\n      conversionType = 'normal';\n    }\n    else if (fromUnit.equivalentExp_ == toUnit.equivalentExp_) {\n      // In this case, the units have the same power of equivalents, so (because\n      // it is not the first case) the units have different powers of mol and mass,\n      // so this must be a conversion between mol and mass.\n      conversionType = 'mol|mass';\n    }\n    else if (fromUnit.moleExp_ == toUnit.moleExp_) {\n      // In this case, the units have the same power of mol, so (because\n      // it is not the first case) the units have different powers of equivalents and mass,\n      // so this must be a conversion between equivalents and mass.\n      conversionType = 'eq|mass';\n    }\n    else if (fromUnit.dim_.getElementAt(this.massDimIndex_) ==\n          toUnit.dim_.getElementAt(this.massDimIndex_)) {\n      // In this case, the units have the same power of mass, so (because\n      // it is not the first case) the units have different powers of equivalents and mol,\n      // so this must be a conversion between equivalents and moles.\n      conversionType = 'eq|mol';\n    }\n    else {\n      // In this case, the units have different powers of mass, mol, and\n      // equivalents, so there is a conversion between mass, mol, and\n      // equivalents.\n      conversionType = 'eq|mol|mass';\n    }\n\n    return conversionType;\n  } // end detectConversionType\n\n\n  /**\n   * @typedef {{\n   *   status: 'succeeded' | 'failed' | 'error',\n   *   toVal: number | null,\n   *   msg: string[],\n   *   suggestions: {\n   *     from: {\n   *       msg: string,\n   *       invalidUnit: string,\n   *       units: string[]\n   *     },\n   *     to: {\n   *       msg: string,\n   *       invalidUnit: string,\n   *       units: string[]\n   *     }\n   *   },\n   *  fromUnit: string,\n   *  toUnit: string\n   * }} ConvertUnitResult\n   */\n\n\n  /**\n   * This method converts one unit to another\n   *\n   * @param {string} fromUnitCode - the unit code/expression/string of the unit to be converted\n   * @param {number | string} fromVal - the number of \"from\" units to be converted to \"to\" units\n   * @param {string} toUnitCode - the unit code/expression/string of the unit that the from field is to be converted to\n   * @param {{\n   *   suggest?: boolean,\n   *   molecularWeight?: number\n   *   charge?: number\n   * }} options\n   *  - suggest: a boolean to indicate whether or not suggestions are requested for a string that cannot be resolved to a valid unit;\n   *    true indicates suggestions are wanted; false indicates they are not, and is the default if the parameter is not specified;\n   *  - molecularWeight: the molecular weight of the substance in question when a conversion is being requested from mass to moles and vice versa.\n   *    This is required when one of the units represents a value in moles.  It is ignored if neither unit includes a measurement in moles.\n   *  - charge: the absolute value of the charge of the substance in question when a conversion is being requested from mass/moles to\n   *    equivalents and vice versa. It is required when one of the units represents a value in equivalents and the other in mass or moles.\n   *    It is ignored if neither unit includes an equivalent unit.\n   * @returns {ConvertUnitResult}\n   * - a hash with six elements:\n   *   - 'status' that will be: 'succeeded' if the conversion was successfully\n   *     calculated; 'failed' if the conversion could not be made, e.g., if\n   *     the units are not commensurable; or 'error' if an error occurred;\n   *   - 'toVal' the numeric value indicating the conversion amount, or null\n   *     if the conversion failed (e.g., if the units are not commensurable);\n   *   - 'msg' is an array message, if the string is invalid or an error occurred,\n   *     indicating the problem, or an explanation of a substitution such as\n   *     the substitution of 'G' for 'Gauss', or an empty array if no\n   *     messages were generated;\n   *   - 'suggestions' if suggestions were requested and found, this is a hash\n   *     that contains at most two elements:\n   *     - 'from' which, if the fromUnitCode input parameter or one or more of\n   *       its components could not be found, is an array one or more hash\n   *       objects.  Each hash contains three elements:\n   *       - 'msg' which is a message indicating what unit expression the\n   *          suggestions are for;\n   *       - 'invalidUnit' which is the unit expression the suggestions\n   *          are for; and\n   *       - 'units' which is an array of data for each suggested unit found.\n   *          Each array will contain the unit code, the unit name and the\n   *          unit guidance (if any).\n   *       If no suggestions were found for the fromUnitCode this element\n   *       will not be included.\n   *     - 'to' which, if the \"to\" unit expression or one or more of its\n   *       components could not be found, is an array one or more hash objects.  Each hash\n   *       contains three elements:\n   *       - 'msg' which is a message indicating what toUnitCode input\n   *          parameter the suggestions are for;\n   *       - 'invalidUnit' which is the unit expression the suggestions\n   *          are for; and\n   *       - 'units' which is an array of data for each suggested unit found.\n   *          Each array will contain the unit code, the unit name and the\n   *          unit guidance (if any).\n   *       If no suggestions were found for the toUnitCode this element\n   *       will not be included.\n   *       No 'suggestions' element will be included in the returned hash\n   *       object if none were found, whether or not they were requested.\n   *   - 'fromUnit' the unit object for the fromUnitCode passed in; returned\n   *     in case it's needed for additional data from the object; and\n   *   - 'toUnit' the unit object for the toUnitCode passed in; returned\n   *     in case it's needed for additional data from the object.\n   */\n  convertUnitTo(fromUnitCode, fromVal, toUnitCode, options = {}) {\n    let {suggest = false, molecularWeight = null, charge = null} = options;\n\n    /** @type {ConvertUnitResult} */\n    let returnObj = {\n      'status': 'failed',\n      'toVal': null,\n      'msg': []\n    };\n\n    if (fromUnitCode) {\n      fromUnitCode = fromUnitCode.trim();\n    }\n    if (!fromUnitCode || fromUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"from\" unit expression specified.');\n    }\n    this._checkFromVal(fromVal, returnObj);\n    if (toUnitCode) {\n      toUnitCode = toUnitCode.trim();\n    }\n    if (!toUnitCode || toUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"to\" unit expression specified.');\n    }\n    if (returnObj['status'] !== 'error') {\n      let fromUnit = null;\n\n      let parseResp = this.getSpecifiedUnit(fromUnitCode, 'convert', suggest);\n      fromUnit = parseResp['unit'];\n      if (parseResp['retMsg'])\n        returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n      if (parseResp['suggestions']) {\n        returnObj['suggestions'] = {};\n        returnObj['suggestions']['from'] = parseResp['suggestions'];\n      }\n      if (!fromUnit) {\n        returnObj['msg'].push(`Unable to find a unit for ${fromUnitCode}, ` +\n          `so no conversion could be performed.`);\n      }\n\n      let toUnit = null;\n      parseResp = this.getSpecifiedUnit(toUnitCode, 'convert', suggest);\n      toUnit = parseResp['unit'];\n      if (parseResp['retMsg'])\n        returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n      if (parseResp['suggestions']) {\n        if (!returnObj['suggestions'])\n          returnObj['suggestions'] = {};\n        returnObj['suggestions']['to'] = parseResp['suggestions'];\n      }\n      if (!toUnit) {\n        returnObj['msg'].push(`Unable to find a unit for ${toUnitCode}, ` +\n          `so no conversion could be performed.`);\n      }\n\n      if (fromUnit && toUnit) {\n        const convertType = this.detectConversionType(fromUnit, toUnit);\n        const msgCountBeforeConvert = returnObj['msg'].length;\n        switch (convertType) {\n          case 'normal':\n            try {\n              returnObj['toVal'] = toUnit.convertFrom(fromVal, fromUnit);\n            } catch (err) {\n              returnObj['msg'].push(err.message);\n            }\n            break;\n          case 'mol|mass':\n            if (!fromUnit.isMolMassCommensurable(toUnit)) {\n              returnObj['msg'].push(`Sorry.  ${fromUnitCode} cannot be ` +\n                `converted to ${toUnitCode}.`);\n              break;\n            }\n            if (!molecularWeight) {\n              returnObj['msg'].push(Ucum.needMoleWeightMsg_);\n              break;\n            }\n            returnObj['toVal'] = fromUnit.convertMolMass(fromVal, toUnit, molecularWeight);\n            break;\n          case 'eq|mass':\n            if (!fromUnit.isEqMassCommensurable(toUnit)) {\n              returnObj['msg'].push(`Sorry.  ${fromUnitCode} cannot be ` +\n                `converted to ${toUnitCode}.`);\n              break;\n            }\n            if (!molecularWeight) {\n              returnObj['msg'].push(Ucum.needEqWeightMsg_);\n            }\n            if (!charge) {\n              returnObj['msg'].push(Ucum.needEqChargeMsg_);\n            }\n            if (!returnObj['msg'].length) {\n              returnObj['toVal'] = fromUnit.convertEqMass(fromVal, toUnit, molecularWeight, charge);\n            }\n            break;\n          case 'eq|mol':\n            if (!fromUnit.isEqMolCommensurable(toUnit)) {\n              returnObj['msg'].push(`Sorry.  ${fromUnitCode} cannot be ` +\n                `converted to ${toUnitCode}.`);\n              break;\n            }\n            if (!charge) {\n              returnObj['msg'].push(Ucum.needEqChargeMsg_);\n              break;\n            }\n            returnObj['toVal'] = fromUnit.convertEqMol(fromVal, toUnit, charge);\n            break;\n          case 'eq|mol|mass':\n            if (!fromUnit.isEqMolMassCommensurable(toUnit)) {\n              returnObj['msg'].push(`Sorry.  ${fromUnitCode} cannot be ` +\n                `converted to ${toUnitCode}.`);\n              break;\n            }\n            if (!molecularWeight) {\n              returnObj['msg'].push(Ucum.needEqWeightMsg_);\n            }\n            if (!charge) {\n              returnObj['msg'].push(Ucum.needEqChargeMsg_);\n            }\n            if (!returnObj['msg'].length) {\n              returnObj['toVal'] = fromUnit.convertEqMolMass(fromVal, toUnit, molecularWeight, charge);\n            }\n            break;\n          default:\n            returnObj['msg'].push(\"Unknown conversion type.  No conversion was attempted.\");\n        }\n        if (returnObj['msg'].length > msgCountBeforeConvert) {\n          // If one or more failure messages are pushed into returnObj['msg']\n          // in the switch statement, mark the status as 'failed'.\n          returnObj['status'] = 'failed';\n        } else {\n          // Set the return object to show success.\n          returnObj['status'] = 'succeeded';\n          returnObj['fromUnit'] = fromUnit;\n          returnObj['toUnit'] = toUnit;\n        }\n      } // end if we have the from and to units\n    }\n\n    return returnObj;\n\n  } // end convertUnitTo\n\n\n  /**\n   *  Converts the given unit string into its base units, their exponents, and\n   *  a magnitude, and returns that data.\n   * @param fromUnit the unit string to be converted to base units information\n   * @param fromVal the number of \"from\" units to be converted\n   * @returns an object with the properties:\n   *  'status' indicates whether the result succeeded.  The value will be one of:\n   *    'succeeded':  the conversion was successfully calculated (which can be\n   *      true even if it was already in base units);\n   *    'invalid':  fromUnit is not a valid UCUM code;\n   *    'failed':  the conversion could not be made (e.g., if it is an \"arbitrary\" unit);\n   *    'error':  if an error occurred (an input or programming error)\n   *  'msg': an array of messages (possibly empty) if the string is invalid or\n   *        an error occurred, indicating the problem, or a suggestion of a\n   *        substitution such as the substitution of 'G' for 'Gauss', or\n   *        an empty array if no messages were generated.  There can also be a\n   *        message that is just informational or warning.\n   *  'magnitude': the new value when fromVal units of fromUnits is expressed in the base units.\n   *  'fromUnitIsSpecial': whether the input unit fromUnit is a \"special unit\"\n   *         as defined in UCUM.  This means there is some function applied to convert\n   *         between fromUnit and the base units, so the returned magnitude is likely not\n   *         useful as a scale factor for other conversions (i.e., it only has validity\n   *         and usefulness for the input values that produced it).\n   *  'unitToExp': a map of base units in fromUnit to their exponent\n   */\n  convertToBaseUnits(fromUnit, fromVal) {\n    let retObj = {};\n    this._checkFromVal(fromVal, retObj);\n    if (!retObj.status) { // could be set to 'error' by _checkFromVal\n      let inputUnitLookup = this.getSpecifiedUnit(fromUnit, 'validate');\n      retObj = {status: inputUnitLookup.status == 'valid' ? 'succeeded' : inputUnitLookup.status};\n      let unit = inputUnitLookup.unit;\n      retObj.msg = inputUnitLookup.retMsg || [];\n      if (!unit) {\n        if (inputUnitLookup.retMsg?.length == 0)\n          retObj.msg.push('Could not find unit information for '+fromUnit);\n      }\n      else if (unit.isArbitrary_) {\n        retObj.msg.push('Arbitrary units cannot be converted to base units or other units.');\n        retObj.status = 'failed';\n      }\n      else if (retObj.status == 'succeeded') {\n        let unitToExp = {};\n        let dimVec = unit.dim_?.dimVec_\n        let baseUnitString = '1';\n        if (dimVec) {\n          let dimVecIndexToBaseUnit = UnitTables.getInstance().dimVecIndexToBaseUnit_;\n          for (let i=0, len=dimVec.length; i<len; ++i) {\n            let exp = dimVec[i];\n            if (exp) {\n              unitToExp[dimVecIndexToBaseUnit[i]] = exp;\n              baseUnitString += '.' + dimVecIndexToBaseUnit[i] + exp;\n            }\n          }\n        }\n\n        // The unit might have a conversion function, which has to be applied; we\n        // cannot just assume unit_.magnitude_ is the magnitude in base units.\n        let retUnitLookup = this.getSpecifiedUnit(baseUnitString, 'validate');\n        // There should not be any error in retUnitLookup, unless there is a bug.\n        let retUnit = retUnitLookup.unit;\n        if (retUnitLookup.status !== 'valid') {\n          retObj.msg.push('Unable construct base unit string; tried '+baseUnitString);\n          retObj.status = 'error';\n        }\n        else {\n          try {\n            retObj.magnitude = retUnit.convertFrom(fromVal, unit);\n          }\n          catch (e) {\n            retObj.msg.push(e.toString());\n            retObj.status = 'error';\n          }\n          if (retObj.status == 'succeeded') {\n            retObj.unitToExp = unitToExp;\n            retObj.fromUnitIsSpecial = unit.isSpecial_;\n          }\n        }\n      }\n    }\n    return retObj;\n  }\n\n\n  /**\n   *  Checks the given value as to whether it is suitable as a \"from\" value in a\n   *  unit conversion.  If it is not, the responseObj will have its status set\n   *  to 'error' and a message added.\n   * @param fromVal The value to check\n   * @param responseObj the object that will be updated if the value is not\n   *  usable.\n   */\n  _checkFromVal(fromVal, responseObj) {\n    if (fromVal === null || isNaN(fromVal) || (typeof fromVal !== 'number' &&\n        !intUtils_.isNumericString(fromVal))) {\n      responseObj.status = 'error';\n      if (!responseObj.msg)\n        responseObj.msg = [];\n      responseObj.msg.push('No \"from\" value, or an invalid \"from\" value, ' +\n                         'was specified.');\n    }\n  }\n\n\n  /**\n   * This method accepts a term and looks for units that include it as\n   * a synonym - or that include the term in its name.\n   *\n   * @param theSyn the term to search for\n   * @returns a hash with up to three elements:\n   *  'status' contains the status of the request, which can be 'error',\n   *    'failed' or succeeded';\n   *  'msg' which contains a message for an error or if no units were found; and\n   *  'units' which is an array that contains one hash for each unit found:\n   *    'code' is the unit's csCode_\n   *    'name' is the unit's name_\n   *    'guidance' is the unit's guidance_\n   *\n   */\n  checkSynonyms(theSyn) {\n    let retObj = {} ;\n    if (theSyn === undefined || theSyn === null) {\n      retObj['status'] = 'error';\n      retObj['msg'] = 'No term specified for synonym search.'\n    }\n    else {\n      retObj = intUtils_.getSynonyms(theSyn);\n    } // end if a search synonym was supplied\n\n    return retObj ;\n\n  } // end checkSynonyms\n\n\n  /**\n   * This method parses a unit string to get (or try to get) the unit\n   * represented by the string.  It returns an error message if no string was specified\n   * or if any errors were encountered trying to get the unit.\n   *\n   * @param uName the expression/string representing the unit\n   * @param valConv indicates what type of request this is for - a request to\n   *  validate (pass in 'validate') or a request to convert (pass in 'convert')\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @returns a hash containing:\n   *   'status' will be 'valid' (uName is a valid UCUM code), 'invalid'\n   *     (the uStr is not a valid UCUM code, and substitutions or\n   *     suggestions may or may not be returned, depending on what was\n   *     requested and found); or 'error' (an input or programming error\n   *     occurred);\n   *   'unit' the unit object (or null if there were problems creating the\n   *     unit);\n   *   'origString' the possibly updated unit string passed in;\n   *   'retMsg' an array of user messages (informational, error or warning) if\n   *     any were generated (IF any were generated, otherwise will be an\n   *     empty array); and\n   *   'suggestions' is an array of 1 or more hash objects.  Each hash\n   *     contains three elements:\n   *       'msg' which is a message indicating what unit expression the\n   *          suggestions are for;\n   *       'invalidUnit' which is the unit expression the suggestions are\n   *          for; and\n   *       'units' which is an array of data for each suggested unit found.\n   *          Each array will contain the unit code, the unit name and the\n   *          unit guidance (if any).\n   *   The return hash will not contain a suggestions array if a valid unit\n   *   was found or if suggestions were not requested and found.\n   */\n  getSpecifiedUnit(uName, valConv, suggest) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    let retObj = {};\n    retObj['retMsg'] = [];\n\n    if (!uName) {\n      retObj['retMsg'].push('No unit string specified.');\n    }\n    else {\n      let utab = UnitTables.getInstance();\n      uName = uName.trim();\n\n      // go ahead and just try using the name as the code.  This may or may not\n      // work, but if it does, it cuts out a lot of parsing.\n      let theUnit = utab.getUnitByCode(uName);\n\n      // If we found it, set the returned unit string to what was passed in;\n      // otherwise try parsing as a unit string\n      if (theUnit) {\n        retObj['unit'] = theUnit ;\n        retObj['origString'] = uName;\n      }\n      else {\n        try {\n          let resp = this.uStrParser_.parseString(uName, valConv, suggest);\n          retObj['unit'] = resp[0];\n          retObj['origString'] = resp[1];\n          if (resp[2])\n            retObj['retMsg'] = resp[2];\n          retObj['suggestions'] = resp[3];\n        }\n        catch (err) {\n          console.log(`Unit requested for unit string ${uName}.` +\n            'request unsuccessful; error thrown = ' + err.message);\n            retObj['retMsg'].unshift(`${uName} is not a valid unit.  ` +\n                                     `${err.message}`);\n        }\n      } // end if the unit was not found as a unit name\n    } // end if a unit expression was specified\n\n    // Set the status field\n    if (!retObj.unit) {\n      // No unit was found; check whether origString has a value\n      retObj.status = !retObj.origString ? 'error' : 'invalid';\n    }\n    else {\n      // Check whether substitutions were made to the unit string in order to\n      // find the unit\n      retObj.status = retObj.origString === uName ? 'valid': 'invalid';\n    }\n\n    return retObj;\n\n  } // end getSpecifiedUnit\n\n\n  /**\n   * This method retrieves a list of units commensurable, i.e., that can be\n   * converted from and to, a specified unit.  Returns an error if the \"from\"\n   * unit cannot be found. If necessary, you can filter the list of units by\n   * specifying a list of unit categories that should be in the resulting list.\n   *\n   * @param {string} fromName - the name/unit string of the \"from\" unit\n   * @param {string[] | null} [categoryList] - the list of unit categories;\n   *   this parameter is optional, defaults to null if not specified;\n   *   possible list values: 'Clinical', 'Nonclinical', 'Obsolete', 'Constant'\n   * @returns an array containing two elements;\n   *   first element is the list of commensurable units if any were found;\n   *   second element is an error message if the \"from\" unit is not found\n   */\n  commensurablesList(fromName, categoryList = null) {\n\n    let retMsg = [];\n    let commUnits = null ;\n    let parseResp = this.getSpecifiedUnit(fromName, 'validate', false);\n    let fromUnit = parseResp['unit'];\n    if (parseResp['retMsg'].length > 0)\n      retMsg = parseResp['retMsg'] ;\n    if (!fromUnit) {\n      retMsg.push(`Could not find unit ${fromName}.`);\n    }\n    else {\n      let dimVec = null ;\n      let fromDim = fromUnit.getProperty('dim_');\n      if (!fromDim) {\n        retMsg.push('No commensurable units were found for ' + fromName) ;\n      }\n      else {\n        try {\n          dimVec = fromDim.getProperty('dimVec_');\n        }\n        catch (err) {\n          retMsg.push(err.message);\n          if (err.message ===\n            \"Dimension does not have requested property(dimVec_)\")\n            dimVec = null;\n        }\n        if (dimVec) {\n          let utab = UnitTables.getInstance();\n          commUnits = utab.getUnitsByDimension(dimVec);\n          if (categoryList) {\n            commUnits = commUnits.filter((item) => {\n              return categoryList.indexOf(item.category_) !== -1;\n            });\n          }\n        }\n      } // end if the from unit has a dimension vector\n    } // end if we found a \"from\" unit\n    return [commUnits , retMsg];\n  } // end commensurablesList\n\n} // end UcumLhcUtils class\n\n\n/**\n *  This function exists ONLY until the original UcumLhcUtils constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UcumLhcUtils object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  NO LONGER TRUE - not implemented as a singleton.  This method retained to\n *  avoid problems with calls to it that exist throughout the code.\n *\n *  @return the (formerly singleton) UcumLhcUtils object.\n */\nUcumLhcUtils.getInstance = function(){\n  return new UcumLhcUtils();\n} ;\n"],"mappings":"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","ignoreList":[]}