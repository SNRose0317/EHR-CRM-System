{"version":3,"file":"unitString.js","names":["intUtils_","_interopRequireWildcard","require","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","Ucum","Unit","UnitTables","PrefixTables","UnitString","constructor","utabs_","getInstance","pfxTabs_","openEmph_","closeEmph_","bracesMsg_","parensFlag_","pFlagLen_","length","braceFlag_","bFlagLen_","vcMsgStart_","vcMsgEnd_","retMsg_","parensUnits_","annotations_","suggestions","useHTMLInMessages","use","undefined","openEmphHTML_","closeEmphHTML_","useBraceMsgForEachString","parseString","uStr","valConv","suggest","trim","Error","valMsgStart_","valMsgEnd_","cnvMsgStart_","cnvMsgEnd_","suggestions_","origString","retObj","_getAnnotations","endProcessing","sUnit","specUnits_","indexOf","replace","_parseTheString","finalUnit","isIntegerUnit","parensResp","_processParens","uArray","mkUArray","_makeUnitsArray","uLen","u1","curCode","parenUnit","_getParensUnit","uRet","_makeUnit","push","_performUnitArithmetic","uString","openBrace","closeBrace","substr","braceStr","substring","VALID_ANNOTATION_REGEX","test","INVALID_ANNOTATION_CHAR_MSG","aIdx","toString","uStrArray","uStrAryPos","stopProcessing","pu","trimmedCt","openCt","closeCt","openPos","closePos","theMsg","c","parseResp","join","uArray1","match","startNumCheck","unshift","isNumericString","numRes","dispVal","parensback","op","un","theOp","validOps_","numRes2","invalidString","parensString","nextParens","parensStr","pStr","retAry","retUnit","befAnnoText","aftAnnoText","psIdx","befText","peIdx","lastIndexOf","aftText","pNumText","csCode_","nMag","getProperty","assignVals","annoRet","_getAnnoText","msg","asIdx","startText","aeIdx","endText","idx","idxNum","_getSuggestions","getSynonyms","suggSet","synLen","s","unit","unitArray","uCode","getUnitByCode","clone","getAnnoRet","_getUnitWithAnnotation","tryCode","ciCode_","addBrackets","name_","retUnitAry","getUnitByName","mString","dupMsg","rStr","RegExp","res","origCode","origUnit","exp","pfxCode","pfxObj","pfxVal","pfxExp","codeAndExp","_isCodeWithExponent","isIntegerUnitWithExp","isNaN","charAt","getPrefixByCode","getValue","getExp","pCodeLen","source_","suggestStat","resetFieldsForDerivedUnit","theDim","theMag","theName","theCiCode","thePrintSymbol","parseInt","expMul","mul","equivalentExp_","moleExp_","Math","pow","cnv_","theCode","getName","getCiCode","getPrintSymbol","expStr","intergerUnitExpSign","annoText","msgLen","tryBrackets","mkUnitRet","pop","toUpperCase","u2","nextUnit","msgString","thisOp","isDiv","divide","multiplyThese","err","message","ret","exports"],"sources":["../source/unitString.js"],"sourcesContent":["/**\n * This class handles the parsing of a unit string into a unit object\n */\n\nvar Ucum = require('./config.js').Ucum;\nvar Unit = require('./unit.js').Unit;\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar PrefixTables = require('./prefixTables.js').PrefixTables;\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\nexport class UnitString {\n\n  /**\n   * Constructor\n   */\n  constructor() {\n\n    // Get instances of the unit and prefix tables and the utilities\n    this.utabs_ = UnitTables.getInstance();\n    this.pfxTabs_ = PrefixTables.getInstance();\n\n    // Set emphasis characters to defaults.  These are used to emphasize\n    // certain characters or strings in user messages.  They can be reset in\n    // the useHTMLInMessages method.\n    this.openEmph_ = Ucum.openEmph_;\n    this.closeEmph_ = Ucum.closeEmph_;\n\n    // Set the braces message to blank.  This message is displayed for each\n    // validation request on the web page, but is included separately as\n    // a note on the validation spreadsheet.  The useBraceMsgForEachString\n    // method should be used to set the message to be displayed for each\n    // unit string.\n    this.bracesMsg_ = '';\n\n    // Set the flags used, with indices, as place holders in unit strings\n    // for parenthetical strings and strings within braces.\n    this.parensFlag_ = \"parens_placeholder\"; // in lieu of Jehoshaphat\n    this.pFlagLen_ = this.parensFlag_.length;\n    this.braceFlag_ = \"braces_placeholder\"; // in lieu of Nebuchadnezzar\n    this.bFlagLen_ = this.braceFlag_.length;\n\n    // Initialize the message start/end strings, which will be set when\n    // parseString is called.\n    this.vcMsgStart_ = null;\n    this.vcMsgEnd_ = null;\n\n    // Arrays used by multiple methods within this class to hold persistent\n    // data.  Just gets too bulky to pass these guys around.\n\n    // Messages to be returned to the calling function\n    this.retMsg_ = [] ;\n\n    // Units for parenthetical unit strings\n    this.parensUnits_ = [] ;\n\n    // annotation text for annotations found in unit strings\n    this.annotations_ = [] ;\n\n    // suggestions for unit strings that for which no unit was found\n    this.suggestions = [] ;\n  } // end constructor\n\n\n  // The start of an error message about an invalid annotation character.\n  static INVALID_ANNOTATION_CHAR_MSG = 'An invalid character was found in the annotation ';\n\n  // A regular expression for validating annotation strings.\n  static VALID_ANNOTATION_REGEX = /^\\{[!-z|~]*\\}$/;\n\n  /**\n   * Sets the emphasis strings to the HTML used in the webpage display - or\n   * blanks them out, depending on the use parameter.\n   *\n   * @param use flag indicating whether or not to use the html message format;\n   *  defaults to true\n   */\n  useHTMLInMessages(use) {\n    if (use === undefined || use) {\n      this.openEmph_ = Ucum.openEmphHTML_;\n      this.closeEmph_ = Ucum.closeEmphHTML_;\n    }\n    else {\n      this.openEmph_ = Ucum.openEmph_;\n      this.closeEmph_ = Ucum.closeEmph_;\n    }\n  } // end useHTMLInMessages\n\n\n  /**\n   * Sets the braces message to be displayed for each unit string validation\n   * requested, as appropriate.\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useBraceMsgForEachString(use) {\n    if (use === undefined || use)\n      this.bracesMsg_ = Ucum.bracesMsg_;\n    else\n      this.bracesMsg_ = '';\n  }\n\n\n  /**\n   * Parses a unit string, returns a unit, a possibly updated version of\n   * the string passed in, and messages and suggestions where appropriate.\n   *\n   * The string returned may be updated if the input string contained unit\n   * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n   * the string returned, a the returned messages array includes a note\n   * explaining the substitution.\n   *\n   * @param uStr the string defining the unit\n   * @param valConv indicates what type of request this is for - a request to\n   *  validate (pass in 'validate') or a request to convert (pass in 'convert');\n   *  optional, defaults to 'validate'\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @returns an array containing:\n   *   the unit object or null if a unit could not be created.  In cases where\n   *     a fix was found for a problem string, .e.g., 2.mg for 2mg, a unit will\n   *     be returned but an error message will also be returned, describing\n   *     the substitution;\n   *   the possibly updated unit string passed in;\n   *   an array of any user messages (informational, error or warning)\n   *     generated (or an empty array); and\n   *   a suggestions array of hash objects (1 or more).  Each hash contains\n   *   three elements:\n   *     'msg' which is a message indicating what unit expression the\n   *       suggestions are for;\n   *     'invalidUnit' which is the unit expression the suggestions are\n   *       for; and\n   *     'units' which is an array of data for each suggested unit found.\n   *        Each array will contain the unit code, the unit name and the\n   *        unit guidance (if any).\n   *   The return array will not contain a suggestions array if a valid unit\n   *   was found or if suggestions were not requested.\n   * @throws an error if nothing was specified.\n   */\n  parseString(uStr, valConv, suggest) {\n\n    uStr = uStr.trim();\n    // Make sure we have something to work with\n    if (uStr === '' || uStr === null) {\n      throw (new Error('Please specify a unit expression to be validated.'));\n    }\n\n    if (valConv === 'validate') {\n      this.vcMsgStart_ = Ucum.valMsgStart_;\n      this.vcMsgEnd_ = Ucum.valMsgEnd_;\n    }\n    else {\n      this.vcMsgStart_ = Ucum.cnvMsgStart_;\n      this.vcMsgEnd_ = Ucum.cnvMsgEnd_;\n    }\n\n    if (suggest === undefined || suggest === false) {\n      this.suggestions_ = null;\n    }\n    else {\n      this.suggestions_ = [] ;\n    }\n\n    this.retMsg_ = [];\n    this.parensUnits_ = [];\n    this.annotations_ = [] ;\n\n    let origString = uStr;\n    let retObj = [];\n\n    // Extract any annotations, i.e., text enclosed in braces ({}) from the\n    // string before further processing.  Store each one in this.annotations_\n    // array and put a placeholder in the string for the annotation.  Do\n    // this before other processing in case an annotation contains characters\n    // that will be interpreted as parenthetical markers or operators in\n    // subsequent processing.\n\n    uStr = this._getAnnotations(uStr);\n    if (this.retMsg_.length > 0) {\n      retObj[0] = null;\n      retObj[1] = null;\n    }\n    else {\n      // Flag used to block further processing on an unrecoverable error\n      let endProcessing = this.retMsg_.length > 0;\n\n      // First check for one of the \"special\" units.  If it's one of those, put\n      // in a substitution phrase for it to avoid having it separated on its\n      // embedded operator.  This will only happen, by the way, if it is\n      // preceded by a prefix or followed by an operator and another unit.\n      let sUnit = null ;\n      for (sUnit in Ucum.specUnits_) {\n        while (uStr.indexOf(sUnit) !== -1)\n          uStr = uStr.replace(sUnit, Ucum.specUnits_[sUnit]);\n      }\n\n      // Check for spaces and throw an error if any are found.  The spec\n      // explicitly forbids spaces except in annotations, which is why any\n      // annotations are extracted before this check is made.\n      if (uStr.indexOf(' ') > -1) {\n        throw (new Error('Blank spaces are not allowed in unit expressions.'));\n      } // end if blanks were found in the string\n\n      // assign the array returned to retObj.  It will contain 2 elements:\n      //  the unit returned in position 0; and the origString (possibly\n      //  modified) in position 1.  The origString in position 1 will not\n      //  be changed by subsequent processing.\n      retObj = this._parseTheString(uStr, origString);\n      let finalUnit = retObj[0];\n\n      // Do a final check to make sure that finalUnit is a unit and not\n      // just a number.  Something like \"8/{HCP}\" will return a \"unit\" of 8\n      // - which is not a unit.  Hm - evidently it is.  So just create a unit\n      // object for it.\n      if (intUtils_.isIntegerUnit(finalUnit) || typeof finalUnit === 'number') {\n        finalUnit = new Unit({\n          'csCode_': origString,\n          'ciCode_': origString,\n          'magnitude_': finalUnit,\n          'name_': origString\n        });\n        retObj[0] = finalUnit;\n      } // end final check\n    } // end if no annotation errors were found\n\n    retObj[2] = this.retMsg_;\n    if (this.suggestions_ && this.suggestions_.length > 0)\n      retObj[3] = this.suggestions_ ;\n    return retObj;\n\n  } // end parseString\n\n\n  /**\n   * Parses a unit string, returns a unit, a possibly updated version of\n   * the string passed in, and messages where appropriate.  This should\n   * only be called from within this class (or by test code).\n   *\n   * The string returned may be updated if the input string contained unit\n   * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n   * the string returned, a the returned messages array includes a note\n   * explaining the substitution.\n   *\n   * @param uStr the string defining the unit\n   * @param origString the original unit string passed in\n   *\n   * @returns\n   *  an array containing:\n   *    the unit object (or null if there were problems creating the unit); and\n   *    the possibly updated unit string passed in.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.parensUnits_ array is referenced and possibly populated by\n   *   methods called within this one\n   * the this.annotations_ array is referenced by methods called within\n   *   this one\n   * the this.suggestions_ array may be populated by methods called within\n   *   this one\n   */\n  _parseTheString(uStr, origString) {\n\n    // Unit to be returned\n    let finalUnit = null;\n\n    // Flag used to block further processing on an unrecoverable error\n    let endProcessing = this.retMsg_.length > 0;\n\n    // Call _processParens to search for and process any/all parenthetical\n    // strings in uStr.  Units created for parenthetical strings will be\n    // stored in the this.parensUnits_ array.\n    let parensResp = this._processParens(uStr, origString);\n    endProcessing = parensResp[2];\n\n    // The array used to hold the units and their operators.\n    let uArray = [];\n\n    // Continue if we didn't hit a problem\n    if (!endProcessing) {\n      uStr = parensResp[0];\n      origString = parensResp[1];\n\n      // Call _makeUnitsArray to convert the string to an array of unit\n      // descriptors with operators.\n      let mkUArray = this._makeUnitsArray(uStr, origString);\n\n      endProcessing = mkUArray[2] ;\n      if (!endProcessing) {\n        uArray = mkUArray[0];\n        origString = mkUArray[1];\n        // Create a unit object out of each un element\n        let uLen = uArray.length;\n        for (let u1 = 0; u1 < uLen; u1++) {\n          //for (let u1 = 0; u1 < uLen && !endProcessing; u1++) {\n          let curCode = uArray[u1]['un'];\n\n          // Determine the type of the \"un\" attribute of the current array element\n\n          // Check to see if it's a number.  If so write the number version of\n          // the number back to the \"un\" attribute and move on\n          if (intUtils_.isIntegerUnit(curCode)) {\n            uArray[u1]['un'] = Number(curCode);\n          }\n\n          else {\n            // The current unit array element is a string.  Check now to see\n            // if it is or contains a parenthesized unit from this.parensUnits_.\n            // If so, call _getParens to process the string and get the unit.\n\n            if (curCode.indexOf(this.parensFlag_) >= 0) {\n              let parenUnit = this._getParensUnit(curCode, origString);\n              // if we couldn't process the string, set the end flag and bypass\n              // further processing.\n              if (!endProcessing)\n                endProcessing = parenUnit[1];\n\n              // If we're good, put the unit in the uArray and replace the\n              // curCode, which contains the parentheses placeholders, etc.,\n              // with the unit's code - including any substitutions.\n              if (!endProcessing) {\n                uArray[u1]['un'] = parenUnit[0];\n              }\n            } // end if the curCode contains a parenthesized unit\n\n            // Else it's not a parenthetical unit and not a number. Call\n            // _makeUnit to create a unit for it.\n            else {\n              let uRet = this._makeUnit(curCode, origString);\n              // If we didn't get a unit, set the endProcessing flag.\n              if (uRet[0] === null) {\n                endProcessing = true;\n              }\n              else {\n                uArray[u1]['un'] = uRet[0];\n                origString = uRet[1];\n              }\n            } // end if the curCode is not a parenthetical expression\n          } // end if the \"un\" array is a not a number\n        } // end do for each element in the units array\n      } // end if _makeUnitsArray did not return an error\n    } // end if _processParens did not find an error that causes a stop\n\n    // If we're still good, continue\n    if (!endProcessing) {\n      // Process the units (and numbers) to create one final unit object\n      if ((uArray[0] === null || uArray[0] === ' ' ||\n           uArray[0]['un'] === undefined || uArray[0]['un'] === null)\n          && this.retMsg_.length === 0) {\n        // not sure what this might be, but this is a safeguard\n        this.retMsg_.push(`Unit string (${origString}) did not contain ` +\n          `anything that could be used to create a unit, or else something ` +\n          `that is not handled yet by this package.  Sorry`);\n        endProcessing = true;\n      }\n    }\n    if (!endProcessing) {\n      finalUnit = this._performUnitArithmetic(uArray, origString);\n    }\n    return [finalUnit, origString];\n  } // end _parseTheString\n\n\n  /**\n   * Extracts all annotations from a unit string, replacing them with\n   * placeholders for later evaluation.  The annotations are stored in the\n   * this.annotations_ array.  This should only be called from within this\n   * class (or by test code).\n   *\n   * @param uString the unit string being parsed\n   * @returns the string after the annotations are replaced with placeholders\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.annotations_ array is populated by this method\n   */\n  _getAnnotations(uString) {\n    let openBrace = uString.indexOf('{');\n    while (openBrace >= 0) {\n\n      let closeBrace = uString.indexOf('}');\n      if (closeBrace < 0) {\n        this.retMsg_.push('Missing closing brace for annotation starting at ' +\n          this.openEmph_ + uString.substr(openBrace) +\n          this.closeEmph_);\n        openBrace = -1;\n      }\n      else {\n        let braceStr = uString.substring(openBrace, closeBrace + 1);\n        // Check for valid characters in the annotation.\n        if (!UnitString.VALID_ANNOTATION_REGEX.test(braceStr)) {\n          this.retMsg_.push(UnitString.INVALID_ANNOTATION_CHAR_MSG +\n            this.openEmph_ + braceStr + this.closeEmph_);\n          openBrace = -1; // end search for annotations\n        }\n        else {\n          let aIdx = this.annotations_.length.toString();\n          uString = uString.replace(braceStr, this.braceFlag_ + aIdx +\n            this.braceFlag_);\n          this.annotations_.push(braceStr);\n          openBrace = uString.indexOf('{');\n        }\n      }\n    } // end do while we have an opening brace\n\n    // check for a stray/unmatched closing brace\n    if (this.retMsg_.length == 0) { // if there were no other errors above\n      let closeBrace = uString.indexOf('}');\n      if (closeBrace >= 0)\n        this.retMsg_.push('Missing opening brace for closing brace found at ' +\n          this.openEmph_ + uString.substring(0, closeBrace + 1) +\n          this.closeEmph_);\n    }\n    return uString;\n  } // end _getAnnotations\n\n\n  /**\n   * Finds and processes any/all parenthesized unit strings. This should only\n   * be called from within this class (or by test code).\n   *\n   * Nested parenthesized strings are processed from the inside out.  The\n   * parseString function is called from within this one for each parenthesized\n   * unit string, and the resulting unit object is stored in this.parensUnits_,\n   * to be processed after all strings are translated to units.\n   *\n   * A placeholder is placed in the unit string returned to indicate that the\n   * unit object should be obtained from the this.parensUnits_ array.  The\n   * placeholder consists of the parenthesis flag (this.parensFlag_) followed\n   * by the index of the unit in this.parensUnits_ followed by this.parensFlag_.\n   *\n   * @param uString the unit string being parsed, where this will be the full\n   *  string the first time this is called and parenthesized strings on any\n   *  subsequent calls\n   * @param origString the original string first passed in to parseString\n   * @returns\n   *  an array containing:\n   *   the string after the parentheses are replaced;\n   *   the original string; and\n   *   a boolean flag indicating whether or not an error occurred that\n   *     should stop processing.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * this this.parensUnits_ array will be populated with units found for\n   *   parenthetical unit strings\n   */\n  _processParens(uString, origString) {\n\n    // Unit strings array and index\n    let uStrArray = [];\n    let uStrAryPos = 0;\n    let stopProcessing = false;\n\n    let pu = this.parensUnits_.length;\n\n    // Count of characters trimmed off the beginning of the unit string (uString)\n    // as units are removed from it; used for error messages to provide\n    // context.\n    let trimmedCt = 0;\n\n    // Break the unit string into pieces that consist of text outside of\n    // parenthetical strings and placeholders for the parenthetical units.\n    // This method is called recursively for parenthetical strings and the units\n    // returned are stored in the this.parensUnits_ array.\n    while (uString !== \"\" && !stopProcessing) {\n      let openCt = 0;\n      let closeCt = 0;\n      let openPos = uString.indexOf('(');\n\n      // If an opening parenthesis was not found, check for an unmatched\n      // close parenthesis.  If one was found report the error and end\n      // processing.\n      if (openPos < 0) {\n        let closePos = uString.indexOf(')');\n        if (closePos >= 0) {\n          let theMsg = `Missing open parenthesis for close ` +\n            `parenthesis at ${uString.substring(0, closePos + trimmedCt)}` +\n            `${this.openEmph_}${uString.substr(closePos, 1)}${this.closeEmph_}`;\n          if (closePos < uString.length - 1) {\n            theMsg += `${uString.substr(closePos + 1)}`;\n          }\n          this.retMsg_.push(theMsg);\n          uStrArray[uStrAryPos] = uString;\n          stopProcessing = true;\n        } // end if a close parenthesis was found\n\n        // If no parentheses were found in the current unit string, transfer\n        // it to the units array and blank out the string, which will end\n        // the search for parenthetical units.\n        else {\n          uStrArray[uStrAryPos] = uString;\n          uString = \"\";\n        } // end if no close parenthesis was found\n      } // end if no open parenthesis was found\n\n      // Otherwise an open parenthesis was found. Process the string that\n      // includes the parenthetical group\n      else {\n        openCt += 1;\n        // Write the text before the parentheses (if any) to the unit strings array\n        let uLen = uString.length;\n        if (openPos > 0) {\n          uStrArray[uStrAryPos++] = uString.substr(0, openPos);\n        }\n\n        // Find the matching closePos, i.e., the one that closes the\n        // parenthetical group that this one opens.  Look also for\n        // another open parenthesis, in case this includes nested parenthetical\n        // strings.  This continues until it finds the same number of close\n        // parentheses as open parentheses, or runs out of string to check.\n        // In the case of nested parentheses this will identify the outer set\n        // of parentheses.\n        let closePos = 0;\n        let c = openPos + 1;\n        for (; c < uLen && openCt != closeCt; c++) {\n          if (uString[c] === '(')\n            openCt += 1;\n          else if (uString[c] === ')')\n            closeCt += 1;\n        }\n\n        // Put a placeholder for the group in the unit strings array and recursively\n        // call this method for the parenthetical group.  Put the unit returned\n        // in this.parensUnits_.  Set the unit string to whatever follows\n        // the position of the closing parenthesis for this group, to be\n        // processed by the next iteration of this loop.  If there's nothing\n        // left uString is set to \"\".\n        if (openCt === closeCt) {\n          closePos = c;\n          uStrArray[uStrAryPos++] = this.parensFlag_ + pu.toString() + this.parensFlag_;\n          let parseResp = this._parseTheString(\n            uString.substring(openPos + 1, closePos - 1), origString);\n          if (parseResp[0] === null)\n            stopProcessing = true;\n          else if (uString[openPos + 1] === '/') {\n            // If the term inside the parenthesis starts with '/', fail the validation. See LF-2854.\n            this.retMsg_.push(\"Unary operator '/' is only allowed at the beginning of the main term, not inside a parenthesis.\");\n            stopProcessing = true;\n          }\n          else {\n            origString = parseResp[1];\n            this.parensUnits_[pu++] = parseResp[0];\n            uString = uString.substr(closePos);\n            trimmedCt = closePos;\n          }\n        } // end if the number of open and close parentheses matched\n\n        // If the number of open and close parentheses doesn't match, indicate\n        // an error.\n        else {\n          uStrArray.push(origString.substr(openPos));\n          this.retMsg_.push(`Missing close parenthesis for open parenthesis at ` +\n            `${origString.substring(0, openPos + trimmedCt)}` +\n            `${this.openEmph_}${origString.substr(openPos, 1)}` +\n            `${this.closeEmph_}${origString.substr(openPos + 1)}`);\n          stopProcessing = true;\n        }\n      } // end if an open parenthesis was found\n    } // end do while the input string is not empty\n    if (stopProcessing)\n      this.parensUnits_ = [];\n    return [uStrArray.join(''), origString, stopProcessing]\n  } // end _processParens\n\n\n  /**\n   * Breaks the unit string into an array of unit descriptors and operators.\n   * If a unit descriptor consists of a number preceding a unit code, with\n   * no multiplication operator, e.g., 2mg instead of 2.mg, it is handled\n   * as if it were a parenthetical expression.\n   *\n   * This should only be called from within this class (or by test code).\n   *\n   * @param uStr the unit string being parsed\n   * @param origString the original string passed to parseString\n   * @returns\n   *  an array containing:\n   *    the array representing the unit string;\n   *    the original string passed in, possibly updated with corrections; and\n   *    and a flag indicating whether or not processing can continue.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _makeUnitsArray(uStr, origString) {\n\n    // Separate the string into pieces based on delimiters / (division) and .\n    // (multiplication).  The idea is to get an array of units on which we\n    // can then perform any operations (prefixes, multiplication, division).\n\n    let uArray1 = uStr.match(/([./]|[^./]+)/g);\n    let endProcessing = false ;\n    let uArray = [];\n    let startNumCheck = /(^[0-9]+)(\\[?[a-zA-Z\\_0-9a-zA-Z\\_]+\\]?$)/ ;\n\n    // If the first element in the array is the division operator (/), the\n    // string started with '/'.  Add a first element containing 1 to the\n    // array, which will cause the correct computation to be performed (inversion).\n    if (uArray1[0] === \"/\") {\n      uArray1.unshift(\"1\");\n    }\n    // If the first element in the array is the multiplication operator (.)\n    // return an error.\n    else if (uArray1[0] === '.') {\n      this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n          `The multiplication operator at the beginning of the expression is ` +\n          `not valid. A multiplication operator must appear only between ` +\n          `two codes.`);\n      endProcessing = true ;\n    }\n    if (!endProcessing) {\n      // Check to see if there is a number preceding a unit code, e.g., 2mg\n      // If so, update the first element to remove the number (2mg -> mg) and\n      // add two elements to the beginning of the array - the number and the\n      // multiplication operator.\n\n      if (!intUtils_.isNumericString(uArray1[0])) {\n        let numRes = uArray1[0].match(startNumCheck);\n        if (numRes && numRes.length === 3 && numRes[1] !== '' &&\n          numRes[2] !== '' && numRes[2].indexOf(this.braceFlag_) !== 0) {\n          let dispVal = numRes[2] ;\n\n          if (!endProcessing && numRes[2].indexOf(this.parensFlag_) !== -1) {\n            let parensback = this._getParensUnit(numRes[2], origString);\n            numRes[2] = parensback[0]['csCode_'];\n            dispVal = `(${numRes[2]})`;\n            endProcessing = parensback[1];\n          }\n          if (!endProcessing) {\n            this.retMsg_.push(`${numRes[1]}${dispVal} is not a valid UCUM code.` +\n              `  ${this.vcMsgStart_}${numRes[1]}.${dispVal}${this.vcMsgEnd_}`);\n            origString = origString.replace(`${numRes[1]}${dispVal}`,\n              `${numRes[1]}.${dispVal}`);\n            uArray1[0] = numRes[2];\n            uArray1.unshift(numRes[1], '.');\n          }\n        }\n      } // end if the first element is not a number (only)\n\n      // Create an array of unit/operator objects.  The unit is, for now, the\n      // string containing the unit code (e.g., Hz for hertz) including\n      // a possible prefix and exponent.   The operator is the operator to be\n      // applied to that unit and the one preceding it.  So, a.b would give\n      // us two objects.  The first will have a unit of a, and a blank operator\n      // (because it's the first unit).  The second would have a unit of b\n      // and the multiplication operator (.).\n      if (!endProcessing) {\n        let u1 = uArray1.length;\n        uArray = [{op: \"\", un: uArray1[0]}];\n        for (let n = 1; n < u1; n++) {\n\n          // check to make sure that we don't have two operators together, e.g.,\n          // mg./K.  If so, let the user know the problem.\n          let theOp = uArray1[n++];\n          // oh wait - check to make sure something is even there, that the\n          // user didn't end the expression with an operator.\n          if (!uArray1[n]) {\n            this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n              `It is terminated with the operator ${this.openEmph_}` +\n              `${theOp}${this.closeEmph_}.`);\n            n = u1;\n            endProcessing = true;\n          }\n          else if (Ucum.validOps_.indexOf(uArray1[n]) !== -1) {\n            this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n              `A unit code is missing between${this.openEmph_}` +\n              `${theOp}${this.closeEmph_}and${this.openEmph_}` +\n              `${uArray1[n]}${this.closeEmph_}in${this.openEmph_}` +\n              `${theOp}${uArray1[n]}${this.closeEmph_}.`);\n            n = u1;\n            endProcessing = true;\n          }\n          else {\n            // Check to see if a number precedes a unit code.\n            // If so, send the element to _processParens, inserting the multiplication\n            // operator where it belongs.  Treating it as parenthetical keeps it from\n            // being interpreted incorrectly because of operator parentheses.  For\n            // example, if the whole string is mg/2kJ we don't want to rewrite it as\n            // mg/2.kJ - because mg/2 would be performed, followed by .kJ.  Instead,\n            // handling 2kJ as a parenthesized unit will make sure mg is divided by\n            // 2.kJ.\n            if (!intUtils_.isNumericString(uArray1[n])) {\n              let numRes2 = uArray1[n].match(startNumCheck);\n              if (numRes2 && numRes2.length === 3 && numRes2[1] !== '' &&\n                numRes2[2] !== '' && numRes2[2].indexOf(this.braceFlag_) !== 0) {\n                let invalidString = numRes2[0];\n                if (!endProcessing && numRes2[2].indexOf(this.parensFlag_) !== -1) {\n                  let parensback = this._getParensUnit(numRes2[2], origString);\n                  numRes2[2] = parensback[0]['csCode_'];\n                  invalidString = `(${numRes2[2]})`;\n                  endProcessing = parensback[1];\n                  if (!endProcessing) {\n                    this.retMsg_.push(`${numRes2[1]}${invalidString} is not a ` +\n                      `valid UCUM code.  ${this.vcMsgStart_}${numRes2[1]}.${invalidString}` +\n                      `${this.vcMsgEnd_}`);\n                    let parensString = `(${numRes2[1]}.${invalidString})`;\n                    origString = origString.replace(`${numRes2[1]}${invalidString}`,\n                      parensString);\n                    let nextParens = this._processParens(parensString, origString);\n                    endProcessing = nextParens[2];\n                    if (!endProcessing) {\n                      uArray.push({op: theOp, un: nextParens[0]});\n                    }\n                    //uArray.push({op: '.', un: numRes2[2]});\n                  }\n                } // end if the string represents a parenthesized unit\n                else {\n                  let parensStr = '(' + numRes2[1] + '.' + numRes2[2] + ')';\n                  let parensResp = this._processParens(parensStr, origString);\n                  // if a \"stop processing\" flag was returned, set the n index to end\n                  // the loop and set the endProcessing flag\n                  if (parensResp[2]) {\n                    n = u1;\n                    endProcessing = true;\n                  }\n                  else {\n                    this.retMsg_.push(`${numRes2[0]} is not a ` +\n                      `valid UCUM code.  ${this.vcMsgStart_}${numRes2[1]}.${numRes2[2]}` +\n                      `${this.vcMsgEnd_}`);\n                    origString = origString.replace(numRes2[0], parensStr);\n                    uArray.push({op: theOp, un: parensResp[0]});\n                  } // end if no error on the processParens call\n                } // end if the string does not represent a parenthesized unit\n              } // end if the string is a number followed by a string\n              else {\n                uArray.push({op: theOp, un: uArray1[n]});\n              }\n            }\n            else {\n              uArray.push({op: theOp, un: uArray1[n]});\n            }\n          } // end if there isn't a missing operator or unit code\n        } // end do for each element in uArray1\n      } // end if a processing error didn't occur in getParensUnit\n    } // end if the string did not begin with a '.' with no following digit\n    return [uArray, origString, endProcessing];\n  } // end _makeUnitsArray\n\n\n  /**\n   * Takes a unit string containing parentheses flags and returns the unit they\n   * represent.  Any text found before and/or after the parenthetical\n   * expression is checked to see if we can tell what the user meant and\n   * let them know what it should have been.  For example, 2(mg), which\n   * would resolve to 2mg, should be 2.mg.\n   *\n   * This should only be called from within this class (or by test code).\n   *\n   * @param pStr the string being parsed\n   * @param origString the original unit string passed in; passed through\n   *  to _getAnnonText if annotation flags are found in any text preceding\n   *  or following the parenthetical unit\n   * @returns\n   *   an array containing\n   *     the unit object; and\n   *     a flag indicating whether or not processing should be ended.\n   *       True indicates that the string was invalid and no corrections\n   *         (substitutions or suggestions) could be found;\n   *       False indicates that it was either valid or substitutions/suggestions\n   *          were made.\n   *   the this.retMsg_ array will be updated with any user messages\n   *     (informational, error or warning) generated by this or called methods\n   *   this this.parensUnits_ array contains the units that are acquired by\n   *     this method\n   * @throws an error if an invalid parensUnit index was found.  This is\n   *    a processing error.\n   */\n  _getParensUnit(pStr, origString) {\n    let endProcessing = false;\n    let retAry = [];\n    let retUnit = null;\n    let befAnnoText = null;\n    let aftAnnoText = null;\n\n    // Get the location of the flags.  We're assuming there are only two\n    // because _processParens takes care of nesting.  By the time we get\n    // here we should not be looking a nested parens.  Also get any text\n    // before and after the parentheses.  Once we get the unit we update\n    // the input string with the unit's csCode_, which will wipe out any\n    // before and after text\n    let psIdx = pStr.indexOf(this.parensFlag_);\n    let befText = null;\n    if (psIdx > 0) {\n      befText = pStr.substring(0, psIdx);\n    }\n    let peIdx = pStr.lastIndexOf(this.parensFlag_);\n    let aftText = null;\n    if (peIdx + this.pFlagLen_ < pStr.length) {\n      aftText = pStr.substr(peIdx + this.pFlagLen_);\n    }\n\n    // Get the text between the flags\n    let pNumText = pStr.substring(psIdx + this.pFlagLen_, peIdx);\n\n    // Make sure the index is a number, and if it is, get the unit from the\n    // this.parensUnits_ array\n    if (intUtils_.isNumericString(pNumText)) {\n      retUnit = this.parensUnits_[Number(pNumText)];\n      if (!intUtils_.isIntegerUnit(retUnit)) {\n        pStr = retUnit.csCode_;\n      }\n      else {\n        pStr = retUnit ;\n      }\n    }\n    // If it's not a number, it's a programming error.  Throw a fit.\n    else {\n      throw (new Error(`Processing error - invalid parens number ${pNumText} ` +\n        `found in ${pStr}.`));\n    }\n\n    // If there's something in front of the starting parentheses flag, check to\n    // see if it's a number or an annotation.\n    if (befText) {\n      // If it's a number, assume that multiplication was assumed\n      if (intUtils_.isNumericString(befText)) {\n        let nMag = retUnit.getProperty('magnitude_');\n        nMag *= Number(befText);\n        retUnit.assignVals({'magnitude_': nMag});\n        pStr = `${befText}.${pStr}`;\n        this.retMsg_.push(`${befText}${pStr} is not a valid UCUM code.\\n` +\n          this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n      }\n      else {\n        if (befText.indexOf(this.braceFlag_) >= 0) {\n          let annoRet = this._getAnnoText(befText, origString);\n          // if we found not only an annotation, but text before or after\n          // the annotation (remembering that this is all before the\n          // parentheses) throw an error - because we don't know what\n          // to do with it.  Could it be missing an operator?\n          if (annoRet[1] || annoRet[2]) {\n            throw (new Error(`Text found before the parentheses (` +\n              `${befText}) included an annotation along with other text ` +\n              `for parenthetical unit ${retUnit.csCode_}`));\n          }\n          // Otherwise put the annotation after the unit string and note\n          // the misplacement.\n          pStr += annoRet[0];\n          this.retMsg_.push(`The annotation ${annoRet[0]} before the unit ` +\n            `code is invalid.\\n` + this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n        }\n        // else the text before the parentheses is neither a number nor\n        // an annotation. Record an error.\n        else {\n          this.retMsg_.push(`${befText} preceding the unit code ${pStr} ` +\n            `is invalid.  Unable to make a substitution.`);\n          endProcessing = true;\n        } // end if a brace was found\n      } // end if text preceding the parentheses was not a number\n    } // end if there was text before the parentheses\n\n    // Process any text after the parentheses\n    if (aftText) {\n      // if it's an annotation, get it and add it to the pStr\n      if (aftText.indexOf(this.braceFlag_) >= 0) {\n        let annoRet = this._getAnnoText(aftText, origString);\n        // if we found not only an annotation, but text before or after\n        // the annotation (remembering that this is all after the\n        // parentheses) throw an error - because we don't know what\n        // to do with it.  Could it be missing an operator?\n        if (annoRet[1] || annoRet[2]) {\n          throw (new Error(`Text found after the parentheses (` +\n            `${aftText}) included an annotation along with other text ` +\n            `for parenthetical unit ${retUnit.csCode_}`));\n        }\n        // Otherwise put the annotation after the unit string - no message\n        // needed.\n        pStr += annoRet[0];\n      }\n      // Otherwise check to see if it's an exponent.  If so, warn the\n      // user that it's not valid - but try it anyway\n      else {\n\n        if (intUtils_.isNumericString(aftText)) {\n          retUnit = null;\n          let msg = `An exponent (${aftText}) following a parenthesis ` +\n            `is invalid as of revision 1.9 of the UCUM Specification.`;\n          // Add the suggestion only if the string in the parenthesis don't end with a number.\n          if (!pStr.match(/\\d$/)) {\n            pStr += aftText;\n            msg += '\\n  ' + this.vcMsgStart_ + pStr + this.vcMsgEnd_;\n          }\n          this.retMsg_.push(msg);\n          endProcessing = true;\n        }\n        // else the text after the parentheses is neither a number nor\n        // an annotation. Record an error.\n        else {\n          this.retMsg_.push(`Text ${aftText} following the unit code ${pStr} ` +\n            `is invalid.  Unable to make a substitution.`);\n          endProcessing = true;\n        } // end if text following the parentheses not an exponent\n      } // end if text following the parentheses is not an annotation\n    } // end if there is text following the parentheses\n    if (!endProcessing) {\n      if (!retUnit) {\n        retUnit = new Unit({\n          'csCode_': pStr,\n          'magnitude_': 1,\n          'name_': pStr});\n      }\n      else if (intUtils_.isIntegerUnit(retUnit)) {\n        retUnit = new Unit({'csCode_': retUnit,\n        'magnitude_': retUnit,\n        'name_': retUnit});\n      }\n      else {\n        retUnit.csCode_ = pStr;\n      }\n    }\n    return [retUnit, endProcessing];\n  } // end _getParensUnit\n\n  /**\n   * Takes a unit string containing annotation flags and returns the\n   * annotation they represent.  This also returns any text found before\n   * the annotation and any found after the annotation.\n   *\n   * This should only be called from within this class (or by test code).\n   * NEEDS FIX in next branch to handle string with multiple annotations.\n   *\n   * @param pStr the string being parsed\n   * @param origString the original string being parsed; used in error msg\n   *  thrown for an invalid index to the annotations array\n   * @returns\n   *  an array containing\n   *    the annotation for the pStr;\n   *    any text found before the annotation; and\n   *    any text found after the annotation.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.annotations_ array is used as the source for the annotations text\n   * @throws an error if for a processing error - an invalid annotation index.\n   */\n  _getAnnoText(pStr, origString) {\n\n    // if the starting braces flag is not at index 0, get the starting\n    // text and the adjust the pStr to omit it.\n    let asIdx = pStr.indexOf(this.braceFlag_);\n    let startText = (asIdx > 0) ? pStr.substring(0, asIdx) : null;\n    if (asIdx !== 0) {\n      pStr = pStr.substr(asIdx);\n    }\n\n    // Get the location of the end flag and, if text follows it, get the text\n    let aeIdx = pStr.indexOf(this.braceFlag_, 1);\n    let endText = ((aeIdx + this.bFlagLen_) < pStr.length) ?\n      pStr.substr(aeIdx + this.bFlagLen_) : null;\n\n    // Get the index of the annotation in this.annotations_.\n    // Check it to make sure it's valid, and if not, throw an error\n    let idx = pStr.substring(this.bFlagLen_, aeIdx);\n    let idxNum = Number(idx);\n    if (!intUtils_.isNumericString(idx) || idxNum >= this.annotations_.length) {\n      throw (new Error(`Processing Error - invalid annotation index ${idx} found ` +\n        `in ${pStr} that was created from ${origString}`));\n    }\n\n    // Replace the flags and annotation index with the annotation expression\n    pStr = this.annotations_[idxNum];\n    return [pStr, startText, endText];\n  } // end _getAnnoText\n\n\n  /**\n   * Takes a unit string and looks for suggested units.  This should be\n   * called for unit strings that cannot be resolved to unit codes.  The\n   * string is searched for in the synonyms table found in the UnitTables\n   * class.  That table includes all synonyms and unit names for the units\n   * in the unit data table.\n   *\n   * @param pStr the string being parsed\n   * @returns an object that contains an element named 'status', whose\n   *  value indicates the status of the request:\n   *   'succeeded' indicates that synonyms were found;\n   *   'failed' indicates that no synonyms were found; or\n   *   'error' which indicates that an error occurred\n   *\n   * the this.retMsg_ array will be updated with a message indicating whether\n   *  or not synonyms/suggestions  were found\n   * the this.suggestions_ array will be updated with a hash (added to the\n   *   array if it already contains others) that contains three elements:\n   *   'msg' which is a message indicating what unit expression the\n   *      suggestions are for;\n   *   'invalidUnit' which is the unit expression the suggestions are for; and\n   *   'units' which is an array of data for each suggested unit found.\n   *       Each array will contain the unit code, the unit name and the\n   *       unit guidance (if any).\n   */\n  _getSuggestions(pStr) {\n\n    let retObj = intUtils_.getSynonyms(pStr);\n    if (retObj['status'] === 'succeeded') {\n      let suggSet = {} ;\n      suggSet['msg'] = `${pStr} is not a valid UCUM code.  We found possible ` +\n                       `units that might be what was meant:`;\n      suggSet['invalidUnit'] = pStr ;\n      let synLen = retObj['units'].length ;\n      suggSet['units'] = [] ;\n      for (let s = 0; s < synLen; s++) {\n        let unit = retObj['units'][s];\n        let unitArray = [unit['code'], unit['name'], unit['guidance']];\n\n        suggSet['units'].push(unitArray) ;\n      }\n      this.suggestions_.push(suggSet);\n    }\n    else {\n      this.retMsg_.push(`${pStr} is not a valid UCUM code.  No alternatives ` +\n                  `were found.`);\n    }\n    return retObj['status'] ;\n  } // end getSuggestions\n\n\n  /**\n   * Creates a unit object from a string defining one unit.  The string\n   * should consist of a unit code for a unit already defined (base or\n   * otherwise).  It may include a prefix and an exponent, e.g., cm2\n   * (centimeter squared).  This should only be called from within this\n   * class (or by test code).\n   *\n   * @params uCode the string defining the unit\n   * @param origString the original string to be parsed; used to provide\n   *  context for messages\n   * @returns\n   *  an array containing:\n   *    a unit object, or null if there were problems creating the unit; and\n   *    the origString passed in, which may be updated if a unit name was\n   *    translated to a unit code.\n   *\n   *  the this.retMsg_ array will be updated with any user messages\n   *    (informational, error or warning) generated by this or called methods\n   *  the this.suggestions_ array will be populated if no unit (with or without\n   *    substitutions) could be found and suggestions were requested\n   */\n  _makeUnit(uCode, origString) {\n\n    // First try the code just as is, without looking for annotations,\n    // prefixes, exponents, or elephants.\n    let retUnit = this.utabs_.getUnitByCode(uCode);\n    if (retUnit) {\n      retUnit = retUnit.clone();\n    }\n\n    // If we found it, we're done.  No need to parse for those elephants (or\n    // other stuff).\n    else if (uCode.indexOf(this.braceFlag_) >= 0) {\n      let getAnnoRet = this._getUnitWithAnnotation(uCode, origString);\n      retUnit = getAnnoRet[0];\n      if (retUnit) {\n        origString = getAnnoRet[1];\n      }\n      // If a unit is not found, retUnit will be returned null and\n      // the this.retMsg_ array will contain a message describing the problem.\n      // If a unit is found, of course, all is good. So ... nothing left\n      // to see here, move along.\n    } // end if the uCode includes an annotation\n\n    else {\n\n      // So we didn't find a unit for the full uCode or for one with\n      // annotations.  Try looking for a unit that uses a carat (^)\n      // instead of an asterisk (*)\n\n      if (uCode.indexOf('^') > -1) {\n        let tryCode = uCode.replace('^', '*');\n        retUnit = this.utabs_.getUnitByCode(tryCode);\n        if (retUnit) {\n          retUnit = retUnit.clone();\n          retUnit.csCode_ = retUnit.csCode_.replace('*', '^');\n          retUnit.ciCode_ = retUnit.ciCode_.replace('*', '^');\n        }\n      }\n      // If that didn't work, check to see if it should have brackets\n      // around it (uCode = degF when it should be [degF]\n      if (!retUnit) {\n        let addBrackets = '[' + uCode + ']' ;\n        retUnit = this.utabs_.getUnitByCode(addBrackets);\n        if (retUnit) {\n          retUnit = retUnit.clone();\n          origString = origString.replace(uCode, addBrackets);\n          this.retMsg_.push(`${uCode} is not a valid unit expression, but ` +\n            `${addBrackets} is.\\n` + this.vcMsgStart_ +\n            `${addBrackets} (${retUnit.name_})${this.vcMsgEnd_}`);\n        } // end if we found the unit after adding brackets\n      } // end trying to add brackets\n\n      // If we didn't find it, try it as a name\n      if (!retUnit) {\n        let retUnitAry = this.utabs_.getUnitByName(uCode);\n        if (retUnitAry && retUnitAry.length > 0) {\n          retUnit = retUnitAry[0].clone();\n          let mString = 'The UCUM code for ' + uCode + ' is ' +\n            retUnit.csCode_ + '.\\n' + this.vcMsgStart_ +\n            retUnit.csCode_ + this.vcMsgEnd_;\n          let dupMsg = false;\n          for (let r = 0; r < this.retMsg_.length && !dupMsg; r++)\n            dupMsg = this.retMsg_[r] === mString;\n          if (!dupMsg)\n            this.retMsg_.push(mString);\n          let rStr = new RegExp('(^|[.\\/({])(' + uCode + ')($|[.\\/)}])');\n          let res = origString.match(rStr);\n          origString = origString.replace(rStr, res[1] + retUnit.csCode_ + res[3]);\n          uCode = retUnit.csCode_;\n        }\n      }\n\n      // If we still don't have a unit, try assuming a modifier (prefix and/or\n      // exponent) and look for a unit without the modifier\n      if (!retUnit) {\n\n        // Well, first see if it's one of the special units.  If so,\n        // replace the placeholder text with the actual unit string, keeping\n        // whatever text (probably a prefix) goes with the unit string.\n        let sUnit = null;\n        for (sUnit in Ucum.specUnits_) {\n          if (uCode.indexOf(Ucum.specUnits_[sUnit]) !== -1)\n            uCode = uCode.replace(Ucum.specUnits_[sUnit], sUnit);\n        }\n        retUnit = this.utabs_.getUnitByCode(uCode);\n        if (retUnit)\n          retUnit = retUnit.clone();\n      }\n      if (!retUnit) {\n\n        let origCode = uCode;\n        let origUnit = null;\n        let exp = null;\n        let pfxCode = null;\n        let pfxObj = null;\n        let pfxVal = null;\n        let pfxExp = null;\n\n        // Look first for an exponent.  If we got one, separate it out and\n        // try to get the unit again\n        let codeAndExp = this._isCodeWithExponent(uCode);\n        let isIntegerUnitWithExp = false;\n        if (codeAndExp) {\n          uCode = codeAndExp[0];\n          exp = codeAndExp[1];\n          isIntegerUnitWithExp = intUtils_.isIntegerUnit(uCode);\n          origUnit = isIntegerUnitWithExp ?\n            new Unit({'csCode_' : uCode,\n              'ciCode_' : uCode,\n              'magnitude_' : Number(uCode),\n              'name_' : uCode}) :\n            this.utabs_.getUnitByCode(uCode);\n        }\n\n        // If an exponent is found but it's not a valid number, e.g. \"2-1\",\n        // mark the unit invalid. Otherwise, the \"-1\" part will be ignored\n        // because parseInt(\"2-1\") results in 2. See LF-2870.\n        if (exp && isNaN(exp)) {\n          retUnit = null;\n          this.retMsg_.push(`${origCode} is not a valid UCUM code.`);\n        }\n        else {\n          // If we still don't have a unit, separate out the prefix, if any,\n          // and try without it.\n          if (!origUnit) {\n            // Try for a single character prefix first.\n            pfxCode = uCode.charAt(0);\n            pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode);\n\n            // if we got a prefix, get its info and remove it from the unit code\n            if (pfxObj) {\n              pfxVal = pfxObj.getValue();\n              pfxExp = pfxObj.getExp();\n              let pCodeLen = pfxCode.length;\n              uCode = uCode.substr(pCodeLen);\n\n              // try again for the unit\n              origUnit = this.utabs_.getUnitByCode(uCode);\n\n              // If we still don't have a unit, see if the prefix could be the\n              // two character \"da\" (deka) prefix.  That's the only prefix with\n              // two characters, and without this check it's interpreted as \"d\"\n              // (deci) and the \"a\" is considered part of the unit code.\n\n              if (!origUnit && pfxCode == 'd' && uCode.substr(0, 1) == 'a') {\n                pfxCode = 'da';\n                pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode);\n                pfxVal = pfxObj.getValue();\n                uCode = uCode.substr(1);\n\n                // try one more time for the unit\n                origUnit = this.utabs_.getUnitByCode(uCode);\n              }\n\n              // Reject the unit we found if it might have another prefix.\n              // Such things are in our tables through the LOINC source_\n              // (ucum.csv) which has guidance and synonyms.  I think it should be\n              // safe to exclude anything whose source is LOINC from having a\n              // prefix.\n              if (origUnit && origUnit.source_ == 'LOINC')\n                origUnit = null;\n            } // end if we found a prefix\n          } // end if we didn't get a unit after removing an exponent\n\n          // If we still haven't found anything, we're done looking.\n          // (We tried with the full unit string, with the unit string\n          // without the exponent, the unit string without a prefix,\n          // common errors, etc. That's all we can try).\n          if (!origUnit) {\n            retUnit = null ;\n            // BUT if the user asked for suggestions, at least look for them\n            if (this.suggestions_) {\n              let suggestStat = this._getSuggestions(origCode);\n            }\n            else {\n              this.retMsg_.push(`${origCode} is not a valid UCUM code.`);\n            }\n          }\n          else {\n            // Otherwise we found a unit object.  Clone it and then apply the\n            // prefix and exponent, if any, to it.  And remove the guidance.\n            retUnit = origUnit.clone();\n            // If we are here, this is only part of the full unit string, so it is\n            // not a base unit, and the synonyms will mostly likely not be correct for the full\n            // string.\n            retUnit.resetFieldsForDerivedUnit();\n            let theDim = retUnit.getProperty('dim_');\n            let theMag = retUnit.getProperty('magnitude_');\n            let theName = retUnit.getProperty('name_');\n            let theCiCode = retUnit.getProperty('ciCode_');\n            let thePrintSymbol = retUnit.getProperty('printSymbol_');\n            // If there is an exponent for the unit, apply it to the dimension\n            // and magnitude now\n            if (exp) {\n              exp = parseInt(exp);\n              let expMul = exp;\n              if (theDim)\n                theDim = theDim.mul(exp);\n              retUnit.equivalentExp_ *= exp;\n              retUnit.moleExp_ *= exp;\n              theMag = Math.pow(theMag, exp);\n              retUnit.assignVals({'magnitude_': theMag});\n\n              // If there is also a prefix, apply the exponent to the prefix.\n              if (pfxObj) {\n\n                // if the prefix base is 10 it will have an exponent.  Multiply\n                // the current prefix exponent by the exponent for the unit\n                // we're working with.  Then raise the prefix value to the level\n                // defined by the exponent.\n                if (pfxExp) {\n                  expMul *= pfxObj.getExp();\n                  pfxVal = Math.pow(10, expMul);\n                }\n                // If the prefix base is not 10, it won't have an exponent.\n                // At the moment I don't see any units using the prefixes\n                // that aren't base 10.   But if we get one the prefix value\n                // will be applied to the magnitude (below) if the unit does\n                // not have a conversion function, and to the conversion prefix\n                // if it does.\n              } // end if there's a prefix as well as the exponent\n            } // end if there's an exponent\n\n            // Now apply the prefix, if there is one, to the conversion\n            // prefix or the magnitude\n            if (pfxObj) {\n              if (retUnit.cnv_) {\n                retUnit.assignVals({'cnvPfx_': pfxVal});\n              }\n              else {\n                theMag *= pfxVal;\n                retUnit.assignVals({'magnitude_': theMag})\n              }\n            }\n            // if we have a prefix and/or an exponent, add them to the unit\n            // attributes - name, csCode, ciCode and print symbol\n            let theCode = retUnit.csCode_;\n            if (pfxObj) {\n              theName = pfxObj.getName() + theName;\n              theCode = pfxCode + theCode;\n              theCiCode = pfxObj.getCiCode() + theCiCode;\n              thePrintSymbol = pfxObj.getPrintSymbol() + thePrintSymbol;\n              retUnit.assignVals({\n                'name_': theName,\n                'csCode_': theCode,\n                'ciCode_': theCiCode,\n                'printSymbol_': thePrintSymbol\n              });\n            }\n            if (exp) {\n              let expStr = exp.toString();\n              const intergerUnitExpSign = isIntegerUnitWithExp && exp > 0 ? '+' : '';\n              retUnit.assignVals({\n                'name_': theName + '<sup>' + expStr + '</sup>',\n                'csCode_': theCode + intergerUnitExpSign + expStr,\n                'ciCode_': theCiCode + intergerUnitExpSign + expStr,\n                'printSymbol_': thePrintSymbol + '<sup>' + expStr + '</sup>'\n              });\n            }\n          } // end if an original unit was found (without prefix and/or exponent)\n        } // end if an invalid exponent wasn't found\n      } // end if we didn't get a unit for the full unit code (w/out modifiers)\n    } // end if we didn't find the unit on the first try, before parsing\n    return [retUnit, origString];\n  } // end _makeUnit\n\n\n  /**\n   * This method handles unit creation when an annotation is included\n   * in the unit string.  This basically isolates and retrieves the\n   * annotation and then calls _makeUnit to try to get a unit from\n   * any text that precedes or follows the annotation.\n   *\n   * @param uCode the string defining the unit\n   * @param origString the original full string submitted to parseString\n   * @returns the unit object found, or null if one could not be found\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _getUnitWithAnnotation(uCode, origString) {\n\n    let retUnit = null;\n\n    // Get the annotation and anything that precedes or follows it.\n    let annoRet = this._getAnnoText(uCode, origString);\n    let annoText = annoRet[0];\n    let befAnnoText = annoRet[1];\n    let aftAnnoText = annoRet[2];\n\n    // Add the warning about annotations - just once.\n\n    if (this.bracesMsg_ && this.retMsg_.indexOf(this.bracesMsg_) === -1)\n      this.retMsg_.push(this.bracesMsg_);\n\n    // If there's no text before or after the annotation, it's probably\n    // something that should be interpreted as a 1, e.g., {KCT'U}.\n    // HOWEVER, it could also be a case where someone used braces instead\n    // of brackets, e.g., {degF} instead of [degF].  Check for that before\n    // we assume it should be a 1.\n    let msgLen = this.retMsg_.length;\n    if (!befAnnoText && !aftAnnoText) {\n      let tryBrackets = '[' + annoText.substring(1, annoText.length - 1) + ']';\n      let mkUnitRet = this._makeUnit(tryBrackets, origString);\n\n      // Nearly anything inside braces is valid, so we don't want to change the\n      // unit, but we can put the found unit in the message as a sort of\n      // warning.\n      if (mkUnitRet[0]) {\n        retUnit = uCode;\n        this.retMsg_.push(`${annoText} is a valid unit expression, but ` +\n          `did you mean ${tryBrackets} (${mkUnitRet[0].name_})?`);\n      }\n      else {\n        // remove error message generated for trybrackets\n        if (this.retMsg_.length > msgLen) {\n          this.retMsg_.pop();\n        }\n      }\n\n      // This is the case where the string is only this annotation.\n      // Create and return a unit object, as we do for numeric units in\n      // parseString.\n      retUnit = new Unit({\n        'csCode_': annoText,\n        'ciCode_': annoText,\n        'magnitude_': 1,\n        'name_': annoText\n      });\n\n    } // end if it's only an annotation\n\n    else {\n      // if there's text before and no text after, assume the text before\n      // the annotation is the unit code (with an annotation following it).\n      // Call _makeUnit for the text before the annotation.\n      if (befAnnoText && !aftAnnoText) {\n        // make sure that what's before the annoText is not a number, e.g.,\n        // /100{cells}.  But f it is a number, just set the return unit to\n        // the number.\n        if (intUtils_.isIntegerUnit(befAnnoText)) {\n          retUnit = new Unit({'csCode_' : befAnnoText + annoText,\n            'ciCode_' : befAnnoText + annoText.toUpperCase(),\n            'magnitude_' : Number(befAnnoText),\n            'name_': befAnnoText + annoText});\n        }\n        // Otherwise try to find a unit\n        else {\n          let mkUnitRet = this._makeUnit(befAnnoText, origString);\n\n          // if a unit was returned\n          if (mkUnitRet[0]) {\n            retUnit = mkUnitRet[0];\n            retUnit.csCode_ += annoText;\n            origString = mkUnitRet[1];\n          }\n          // Otherwise add a not found message\n          else {\n            this.retMsg_.push(`Unable to find a unit for ${befAnnoText} that ` +\n              `precedes the annotation ${annoText}.`);\n          }\n        }\n      }\n      // else if there's only text after the annotation, try for a unit\n      // from the after text and assume the user put the annotation in\n      // the wrong place (and tell them)\n      else if (!befAnnoText && aftAnnoText) {\n\n        // Again, test for a number and if it is a number, set the return\n        // unit to the number.\n        if (intUtils_.isIntegerUnit(aftAnnoText)) {\n          retUnit = aftAnnoText + annoText ;\n          this.retMsg_.push(`The annotation ${annoText} before the `\n            `${aftAnnoText} is invalid.\\n` + this.vcMsgStart_ + retUnit +\n            this.vcMsgEnd_);\n        }\n        else {\n          let mkUnitRet = this._makeUnit(aftAnnoText, origString);\n          if (mkUnitRet[0]) {\n            retUnit = mkUnitRet[0];\n            retUnit.csCode_ += annoText;\n            origString = retUnit.csCode_;\n            this.retMsg_.push(`The annotation ${annoText} before the unit ` +\n              `code is invalid.\\n` + this.vcMsgStart_ + retUnit.csCode_ +\n              this.vcMsgEnd_);\n          }\n          // Otherwise add a not found message\n          else {\n            this.retMsg_.push(`Unable to find a unit for ${befAnnoText} that ` +\n              `follows the annotation ${annoText}.`);\n          }\n        }\n      }\n      // else it's got text before AND after the annotation.  Now what?\n      // For now this is an error.  This may be a case of a missing\n      // operator but that is not handled yet.\n      else {\n        this.retMsg_.push(`Unable to find a unit for ${befAnnoText}${annoText}` +\n          `${aftAnnoText}.\\nWe are not sure how to interpret text both before ` +\n          `and after the annotation.  Sorry`);\n      }\n    } // else if there's text before/and or after the annotation\n\n    return [retUnit , origString];\n\n  } // end _getUnitWithAnnotations\n\n\n  /**\n   * Performs unit arithmetic for the units in the units array.  That array\n   * contains units/numbers and the operators (division or multiplication) to\n   * be performed on each unit/unit or unit/number pair in the array.  This\n   * should only be called from within this class (or by test code).\n   *\n   * @params uArray the array that contains the units, numbers and operators\n   *  derived from the unit string passed in to parseString\n   * @param origString the original string to be parsed; used to provide\n   *  context for messages\n   *\n   * @returns a single unit object that is the result of the unit arithmetic\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _performUnitArithmetic(uArray, origString) {\n\n    let finalUnit = uArray[0]['un'];\n    if (intUtils_.isIntegerUnit(finalUnit)) {\n      finalUnit = new Unit({'csCode_' : finalUnit, 'ciCode_' : finalUnit,\n        'magnitude_' : Number(finalUnit),\n        'name_' : finalUnit}) ;\n    }\n    let uLen = uArray.length ;\n    let endProcessing = false ;\n    // Perform the arithmetic for the units, starting with the first 2 units.\n    // We only need to do the arithmetic if we have more than one unit.\n    for (let u2 = 1; (u2 < uLen) && !endProcessing; u2++) {\n      let nextUnit = uArray[u2]['un'];\n      if (intUtils_.isIntegerUnit(nextUnit)) {\n        nextUnit = new Unit({'csCode_' : nextUnit, 'ciCode_' : nextUnit,\n          'magnitude_' : Number(nextUnit),\n          'name_': nextUnit});\n      }\n      if (nextUnit === null ||\n          ((typeof nextUnit !== 'number') && (!nextUnit.getProperty))) {\n        let msgString = `Unit string (${origString}) contains unrecognized ` +\n                        'element' ;\n        if (nextUnit) {\n          msgString += ` (${this.openEmph_}${nextUnit.toString()}` +\n                       `${this.closeEmph_})`;\n        }\n        msgString += '; could not parse full string.  Sorry';\n        this.retMsg_.push(msgString);\n        endProcessing = true;\n      }\n      else {\n        try {\n          // Is the operation division?\n          let thisOp = uArray[u2]['op'];\n          let isDiv = thisOp === '/';\n\n          // Perform the operation.  Both the finalUnit and nextUnit\n          // are unit objects.\n          isDiv ? finalUnit = finalUnit.divide(nextUnit) :\n                  finalUnit = finalUnit.multiplyThese(nextUnit);\n        }\n        catch (err) {\n          this.retMsg_.unshift(err.message) ;\n          endProcessing = true ;\n          finalUnit = null ;\n        }\n      } // end if we have another valid unit/number to process\n    } // end do for each unit after the first one\n    return finalUnit ;\n  }  // end _performUnitArithmetic\n\n\n  /**\n   * This tests a string to see if it starts with characters and ends with\n   * digits.  This is used to test for an exponent on a UCUM code (or what\n   * we think might be a UCUM code).  This is broken out to a separate\n   * function so that the regular expression can be verified to provide the\n   * results we expect, in case someone changes it.  (Per Paul Lynch)\n   * See \"Test _isCodeWithExponent method\" in testUnitString.spec.js\n   *\n   * This particular regex has been tweaked several times.  This one\n   * works with the following test strings:\n   * \"m[H2O]-21 gives [\"m[H2O]-21\", \"m[H2O]\", \"-21\"]\n   * \"m[H2O]+21 gives [\"m[H2O]+21\", \"m[H2O]\", \"+21\"]\n   * \"m[H2O]21 gives [\"m[H2O]-21\", \"m[H2O]\", \"21\"]\n   * \"s2\" gives [\"s2\", \"s, \"2\"]\n   * \"kg\" gives null\n   * \"m[H2O]\" gives null\n   * \"m[H2O]23X\" gives null\n   *\n   * @params uCode the code being tested\n   * @returns an array containing: (1) the code without the exponent (or\n   *  trailing number); and (2) the exponent/trailing number.  Returns null\n   *  if there is no trailing number or something follows the trailing\n   *  number, or if the first part is not characters.\n   */\n  _isCodeWithExponent(uCode) {\n\n    let ret = [] ;\n    let res = uCode.match(/(^[^\\-\\+]+?)([\\-\\+\\d]+)$/);\n\n    // If we got a return with an exponent, separate the exponent from the\n    // unit and return both (as separate values)\n    if (res && res[2] && res[2] !== \"\") {\n      ret.push(res[1]);\n      ret.push(res[2]);\n    } // end if we got an exponent\n    else {\n      ret = null ;\n    }\n    return ret ;\n  } // end _isCodeWithExponent\n\n} // end class UnitString\n\n\n/**\n *  This function exists ONLY until the original UnitString constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UnitString object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  @return the singleton UnitString object.\n */\nUnitString.getInstance = function(){\n  return new UnitString();\n} ;\n\n/*\n// Perform the first request for the object, to set the getInstance method.\nUnitString.getInstance();\n\n*/\n"],"mappings":"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","ignoreList":[]}